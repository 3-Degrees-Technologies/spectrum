#!/bin/bash
# write_ticket command for Agent-Knowledge
# Automates: Agent brief -> Template selection -> Ticket creation -> Auto-validation

# Colors and emoji
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'
SUCCESS="âœ…"
ERROR="âŒ"
WARNING="âš ï¸"
INFO="ðŸ“‹"
WORKING="ðŸ”„"
INPUT="ðŸ“"
CREATE="ðŸŽ«"
VALIDATE="âœ¨"
TEMPLATE="ðŸ“„"

# Helper function to ensure project config exists
ensure_project_config() {
    local config_file=".project_config.json"
    
    # If config doesn't exist or is empty, create it
    if [ ! -f "$config_file" ] || [ ! -s "$config_file" ]; then
        echo "ðŸ“‹ Initializing project configuration..." >&2
        
        # Get project info from saber.py discover
        local discover_output=$(python3 .tools/saber.py discover 2>/dev/null)
        if [ $? -eq 0 ]; then
            # Extract project info - look for lines with â­ CURRENT TEAM
            local project_key=$(echo "$discover_output" | grep -B2 "â­ CURRENT TEAM" | grep "Key:" | cut -d' ' -f2)
            local project_name=$(echo "$discover_output" | grep -B4 "â­ CURRENT TEAM" | grep "Name:" | cut -d' ' -f2)
            
            if [ -n "$project_key" ] && [ -n "$project_name" ]; then
                # Create config JSON
                cat > "$config_file" << EOF
{
  "project_key": "$project_key",
  "project_name": "$project_name",
  "linear_org": "$(echo "$project_name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "source": "saber_discover"
}
EOF
                echo "âœ… Project config created: $project_key ($project_name)" >&2
            else
                # Fallback config
                cat > "$config_file" << EOF
{
  "project_key": "PLY",
  "project_name": "FoxyPlayer",
  "linear_org": "foxyplayer",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "source": "fallback"
}
EOF
                echo "âš ï¸ Using fallback project config" >&2
            fi
        else
            # Fallback config if saber fails
            cat > "$config_file" << EOF
{
  "project_key": "PLY",
  "project_name": "FoxyPlayer", 
  "linear_org": "foxyplayer",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "source": "fallback"
}
EOF
            echo "âš ï¸ Saber discovery failed, using fallback config" >&2
        fi
    fi
}

# Helper function to get project prefix
get_project_prefix() {
    ensure_project_config
    python3 -c "import json; print(json.load(open('.project_config.json'))['project_key'])" 2>/dev/null || echo "PLY"
}

# Helper function to get project name
get_project_name() {
    ensure_project_config
    python3 -c "import json; print(json.load(open('.project_config.json'))['project_name'])" 2>/dev/null || echo "FoxyPlayer"
}

# Helper function to get Linear organization URL
get_linear_org_url() {
    ensure_project_config
    python3 -c "import json; print(json.load(open('.project_config.json'))['linear_org'])" 2>/dev/null || echo "foxyplayer"
}

# Usage check
if [ $# -lt 3 ]; then
    echo -e "${ERROR} Usage: ./write_ticket <type> <title> <brief> [parent_id]"
    echo -e "${INFO} Types: research, design, implementation"
    echo -e "${INFO} Example: ./write_ticket implementation 'JWT Middleware' 'Need JWT validation middleware' SPE-9"
    exit 1
fi

type_input="$1"
ticket_title="$2"
agent_brief="$3"
parent_id="$4"

# Map type names
case $type_input in
    "research"|"1") ticket_type=1; type_name="Research" ;;
    "design"|"2") ticket_type=2; type_name="Design" ;;
    "implementation"|"3") ticket_type=3; type_name="Implementation" ;;
    *) echo -e "${ERROR} Invalid type. Use: research, design, or implementation"; exit 1 ;;
esac

echo -e "${INFO} ${BLUE}Agent-Knowledge Ticket Creation Framework${NC}"
echo -e "${CREATE} Creating ${type_name} ticket: ${ticket_title}"
echo -e "${INFO} Brief: ${agent_brief}"
if [ -n "$parent_id" ]; then
    echo -e "${INFO} Parent: ${parent_id}"
fi
echo ""

# Step 2: Apply domain context and templates
echo -e "${TEMPLATE} Applying ${type_name} template..."
echo -e "${WORKING} Generating ticket content..."

# Generate ticket description based on type
case $ticket_type in
    1) # Research Template
        ticket_description="# ${ticket_title}

**Objective**
Research and analyze ${agent_brief} to provide foundation for design and implementation decisions.

**Context**
${agent_brief} requires thorough analysis to understand current patterns, identify best approaches, and establish requirements for future implementation.

**Task**
Conduct comprehensive research on ${agent_brief}:

* Analyze existing patterns and implementations in the codebase
* Research industry best practices and approaches
* Identify integration points with current architecture
* Document findings with concrete recommendations
* Establish requirements and constraints for future phases

**Key Research Areas**

* **Existing Patterns**: How is similar functionality currently implemented?
* **Integration Points**: What existing systems need to integrate with this functionality?
* **Best Practices**: What are the recommended approaches in the industry?
* **Constraints**: What technical and business constraints affect implementation?
* **Requirements**: What functional and non-functional requirements need to be met?

**Success Criteria**

* Current patterns documented and analyzed
* Industry best practices researched and compared
* Integration requirements identified and documented
* Technical constraints and considerations documented
* Clear recommendations provided for design phase
* Research findings ready for design phase planning

**Labels**
research"
        ;;
    2) # Design Template
        ticket_description="# ${ticket_title}

**Objective**
Define the functional requirements and integration patterns for ${agent_brief}.

**Context**
Based on research findings, this design phase explores what ${agent_brief} should functionally accomplish and how it integrates with existing systems.

**Task**
Explore and define the functional integration patterns for ${agent_brief}:

* How should this functionality integrate with existing architectural patterns?
* What contracts and interfaces should be defined?
* How should error handling and edge cases be managed?
* What operational visibility and monitoring is needed?
* How should this fit with existing architectural patterns?

**Key Functional Questions to Answer**

* **Integration Flow**: What is the expected workflow and integration points?
* **Contracts**: What interfaces and contracts need to be defined?
* **Error Handling**: What failure modes exist and how should recovery work?
* **Observability**: What information do operators need for monitoring and debugging?
* **Architectural Patterns**: How does this align with existing architectural patterns?

**Success Criteria**

* Functional workflow defined with clear integration points
* Contracts and interfaces specified for consistent behavior
* Error handling and recovery patterns specified
* Operational monitoring and debugging requirements identified
* Integration approach with existing systems documented
* Functional requirements ready for implementation planning

**Labels**
design"
        ;;
    3) # Implementation Template
        ticket_description="# ${ticket_title}

**Objective**
${agent_brief} following test-driven development approach.

**Context**
Based on design specifications, implement the functionality with focus on correctness and integration with existing systems.

**Domain Implementation Rule**
âš ï¸ **CRITICAL**: Implement ALL domain-related code in a SINGLE FILE. Do not follow standard Android separation patterns.

* If this is authentication-related â†’ Put everything in \`auth.kt\`
* If this is music discovery-related â†’ Put everything in \`music.kt\`
* If this is playback-related â†’ Put everything in \`playback.kt\`
* Include: Models, Repository, UseCase, Screen, ViewModel - ALL in one file
* **Ignore Kotlin conventions** that separate layers into different files
* **Context window optimization**: AI needs all domain code visible simultaneously

**Task**
${agent_brief} using TDD methodology:

* Write tests covering functional requirements
* Implement core functionality following established patterns
* Add error handling for edge cases
* Add logging and monitoring instrumentation
* Validate integration with existing systems

**Implementation Approach**

* Follow test-driven development with comprehensive test coverage
* Use existing patterns and conventions
* Ensure clean integration with existing architecture
* **Keep all domain code in single file for AI context optimization**

**Definition of Done**

* Tests written and passing for all functionality
* Core functionality implemented following established patterns
* Error handling implemented for identified failure modes
* Integration with existing systems validated
* **ALL domain code consolidated in single file**
* Code review completed and approved

**Labels**
backend, implementation"
        ;;
esac

# Step 3: Create ticket
echo -e "${CREATE} Creating ticket in Linear..."
echo -e "${WORKING} Creating ${type_name} ticket: ${ticket_title}"

# Create the ticket
create_result=$(python3 .tools/saber.py create "$ticket_title" "$ticket_description" 2>/dev/null)
if [ $? -ne 0 ]; then
    echo -e "${ERROR} Failed to create ticket"
    exit 1
fi

# Extract ticket ID from result using stored prefix
project_prefix=$(get_project_prefix)
ticket_id=$(echo "$create_result" | grep -oE "${project_prefix}-[0-9]+" | head -1)
if [ -z "$ticket_id" ]; then
    echo -e "${ERROR} Could not extract ticket ID from creation result"
    echo -e "${INFO} Create result: $create_result"
    echo -e "${INFO} Expected pattern: ${project_prefix}-XXX"
    exit 1
fi

echo -e "${SUCCESS} Created ticket: ${ticket_id}"

# Set parent relationship if provided
if [ -n "$parent_id" ]; then
    echo -e "${WORKING} Setting parent relationship to ${parent_id}..."
    parent_result=$(python3 .tools/saber.py parent "$ticket_id" "$parent_id" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo -e "${SUCCESS} Parent relationship set"
    else
        echo -e "${WARNING} Failed to set parent relationship"
    fi
fi

# Step 4: Auto-validate created ticket
echo -e "${VALIDATE} Auto-validating created ticket..."
echo -e "${WORKING} Running validation on ${ticket_id}..."

# Run validation script if it exists
if [ -f "./validate_ticket" ]; then
    echo ""
    ./validate_ticket "$ticket_id"
    validation_exit_code=$?
    echo ""
    
    if [ $validation_exit_code -eq 0 ]; then
        echo -e "${SUCCESS} Ticket validation passed"
    else
        echo -e "${WARNING} Ticket validation found issues - consider refinement"
    fi
else
    echo -e "${INFO} Validation script not found, skipping auto-validation"
fi

# Step 5: Creation complete
echo -e "${SUCCESS} ${GREEN}Ticket Creation Complete!${NC}"
echo -e "${INFO} Ticket ID: ${ticket_id}"
echo -e "${INFO} Title: ${ticket_title}"
echo -e "${INFO} Type: ${type_name}"
if [ -n "$parent_id" ]; then
    echo -e "${INFO} Parent: ${parent_id}"
fi
linear_org=$(get_linear_org_url)
echo -e "${INFO} Linear URL: https://linear.app/${linear_org}/issue/${ticket_id}"
echo -e "${BLUE}Ticket ready for assignment!${NC}"