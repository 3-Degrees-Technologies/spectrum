#!/bin/bash
# Unified Ticket Validation Tool
# Layered validation with graceful fallback: Domain-Aware ‚Üí Example-Based ‚Üí Basic

# Colors and emoji
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'
SUCCESS="‚úÖ"
ERROR="‚ùå"
WARNING="‚ö†Ô∏è"
INFO="üìã"
WORKING="üîÑ"
CHECK="üîç"
BREAKDOWN="üî®"
VALIDATE="‚ú®"
EXAMPLE="üìñ"
DOMAIN="üéØ"
LAYER="üèóÔ∏è"

# Default settings
MODE="auto"
VERBOSE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --mode=*)
            MODE="${1#*=}"
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 <TICKET_ID> [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --mode=auto      Auto-detect best validation mode (default)"
            echo "  --mode=adaptive  Force adaptive domain detection"  
            echo "  --mode=enhanced  Force example-based validation"
            echo "  --mode=basic     Force basic pattern matching"
            echo "  --verbose        Show detailed analysis steps"
            echo "  --help           Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0 CEN-48                    # Auto-detect validation mode"
            echo "  $0 CEN-48 --mode=adaptive   # Use domain matrices"
            echo "  $0 CEN-48 --verbose         # Show detailed analysis"
            exit 0
            ;;
        --*)
            echo -e "${ERROR} Unknown option: $1"
            echo -e "${INFO} Use --help for usage information"
            exit 1
            ;;
        *)
            if [[ -z "$TICKET_ID" ]]; then
                TICKET_ID="$1"
            else
                echo -e "${ERROR} Multiple ticket IDs not supported: $1"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate ticket ID provided
if [[ -z "$TICKET_ID" ]]; then
    echo -e "${ERROR} Usage: $0 <TICKET_ID> [OPTIONS]"
    echo -e "${INFO} Example: $0 CEN-48 --verbose"
    echo -e "${INFO} Use --help for more options"
    exit 1
fi

# Capability detection
detect_capabilities() {
    local has_business_domains=false
    local has_technical_domains=false
    local has_examples=false
    
    if [[ -f "BUSINESS_DOMAINS.md" ]]; then
        has_business_domains=true
    fi
    
    if [[ -f "TECHNICAL_DOMAINS.md" ]]; then
        has_technical_domains=true
    fi
    
    if [[ -f "GOOD_IMPLEMENTATION_TICKET_EXAMPLE.md" ]] || [[ -f "BAD_TICKET_EXAMPLE.md" ]]; then
        has_examples=true
    fi
    
    # Determine effective validation mode
    case "$MODE" in
        "auto")
            if [[ "$has_business_domains" == true && "$has_technical_domains" == true ]]; then
                EFFECTIVE_MODE="adaptive"
            elif [[ "$has_examples" == true ]]; then
                EFFECTIVE_MODE="enhanced"
            else
                EFFECTIVE_MODE="basic"
            fi
            ;;
        "adaptive")
            if [[ "$has_business_domains" == true && "$has_technical_domains" == true ]]; then
                EFFECTIVE_MODE="adaptive"
            else
                echo -e "${WARNING} Domain matrices not found, falling back to enhanced mode"
                EFFECTIVE_MODE="enhanced"
            fi
            ;;
        "enhanced")
            EFFECTIVE_MODE="enhanced"
            ;;
        "basic")
            EFFECTIVE_MODE="basic"
            ;;
        *)
            echo -e "${ERROR} Invalid mode: $MODE"
            exit 1
            ;;
    esac
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${LAYER} ${BLUE}Validation Capabilities Detected:${NC}"
        echo -e "${INFO} Business Domains: ${has_business_domains}"
        echo -e "${INFO} Technical Domains: ${has_technical_domains}"  
        echo -e "${INFO} Example Patterns: ${has_examples}"
        echo -e "${INFO} Requested Mode: ${MODE}"
        echo -e "${INFO} Effective Mode: ${EFFECTIVE_MODE}"
        echo ""
    fi
}

# Header
echo -e "${INFO} ${BLUE}Unified Ticket Validation Tool${NC}"
echo -e "${VALIDATE} Validating ${TICKET_ID} with layered approach..."

# Detect capabilities and set effective mode
detect_capabilities

if [[ "$VERBOSE" == false ]]; then
    echo -e "${LAYER} Validation Mode: ${EFFECTIVE_MODE}"
fi
echo ""

# Step 1: Get ticket details (common across all modes)
echo -e "${CHECK} Step 1: Retrieving ticket details..."
if [[ "$VERBOSE" == true ]]; then
    echo -e "${WORKING} Getting ticket information..."
fi

ticket_details=$(python3 .tools/saber.py get "$TICKET_ID" 2>/dev/null)
if [ $? -ne 0 ]; then
    echo -e "${ERROR} Failed to find ticket ${TICKET_ID}"
    exit 1
fi

# Extract key information
ticket_title=$(echo "$ticket_details" | jq -r '.title // "Unknown"')
ticket_description=$(echo "$ticket_details" | jq -r '.description // ""')
ticket_state=$(echo "$ticket_details" | jq -r '.state.name // "Unknown"')
parent_id=$(echo "$ticket_details" | jq -r '.parent.identifier // null')
children=$(echo "$ticket_details" | jq -r '.children.nodes[].identifier // empty')
children_count=$(echo "$ticket_details" | jq -r '.children.nodes | length')

echo -e "${SUCCESS} Retrieved: ${ticket_title}"
if [[ "$VERBOSE" == true ]]; then
    echo -e "${INFO} Status: ${ticket_state}"
    if [[ "$parent_id" != "null" ]]; then
        echo -e "${INFO} Parent: ${parent_id}"
    fi
    if [[ "$children_count" -gt 0 ]]; then
        echo -e "${INFO} Children (${children_count}): ${children}"
    fi
fi

# CRITICAL: Parent ticket validation (Golden Rule check)
if [[ "$children_count" -gt 0 ]]; then
    echo -e "${ERROR} ${RED}PARENT TICKET DETECTED - ASSIGNMENT BLOCKED${NC}"
    echo -e "${INFO} This ticket has ${children_count} child tickets: ${children}"
    echo -e "${INFO} Golden Rule Violation: Tickets have EITHER work OR subtasks, NEVER both"
    echo ""
    echo -e "${BLUE}Required Action:${NC}"
    echo -e "${INFO} ‚Ä¢ Parent tickets should coordinate work, not be assigned for implementation"
    echo -e "${INFO} ‚Ä¢ Assign agents to child tickets instead:"
    for child in $children; do
        echo -e "${INFO}   - Assign agent to $child for focused implementation work"
    done
    echo ""
    echo -e "${ERROR} ${RED}VALIDATION FAILED - DO NOT ASSIGN THIS TICKET${NC}"
    exit 1
fi

# Initialize analysis variables (used across all modes)
good_pattern_matches=()
bad_pattern_indicators=()
concerns=()
confidence_score=0

# Combine ticket title and description for analysis
ticket_content=$(echo "${ticket_title} ${ticket_description}" | tr '[:upper:]' '[:lower:]')

#############################################################################
# LAYER 1: DOMAIN-AWARE VALIDATION (if available)
#############################################################################

if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
    echo -e "${CHECK} Step 2: Domain matrix analysis..."
    
    # Function to extract keywords from domain matrix
    extract_domain_keywords() {
        local domain_file="$1"
        local section_name="$2"
        
        if [[ -f "$domain_file" ]]; then
            awk -v section="### $section_name" '
                $0 ~ section { found=1; next }
                found && /^### / && $0 !~ section { found=0 }
                found && /^\*\*Keywords:\*\*/ { 
                    gsub(/\*\*Keywords:\*\* /, ""); 
                    gsub(/, /, " ");
                    print $0 
                }
            ' "$domain_file"
        fi
    }
    
    # Load domain matrices
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${SUCCESS} Loading domain matrices..."
    fi
    
    #EXAMPLE
    # Load business domains
    # business_domains[Authentication]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Authentication")
    # business_domains[File_Discovery]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "File Discovery")
    # business_domains[Audio_Streaming]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Audio Streaming")
    # business_domains[Playback_Control]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Playback Control")
    # business_domains[Music_Library]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Music Library")
    # business_domains[Background_Services]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Background Services")
    
    # Load technical domains
    # technical_domains[Android_UI]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Android UI")
    # technical_domains[API_Client]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "API Client")
    # technical_domains[Storage_Persistence]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Storage & Persistence")
    # technical_domains[State_Management]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "State Management")
    # technical_domains[Audio_Engine]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Audio Engine")
    # technical_domains[Background_Services_Tech]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Background Services")
    # technical_domains[Testing_Quality]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Testing & Quality")
    
    # Load business domains
    declare -A business_domains
    business_domains[Balance]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Balance")
    business_domains[Quote]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Quote")
    business_domains[Payout]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Payout")
    business_domains[Routing]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Routing")
    business_domains[Tenant]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Tenant")
    business_domains[Auth]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Auth")
    business_domains[Provider]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Provider")
    business_domains[EventSourcing]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "EventSourcing")
    business_domains[Health]=$(extract_domain_keywords "BUSINESS_DOMAINS.md" "Health")
    
    # Load technical domains
    declare -A technical_domains
    technical_domains[AWS_Lambda_Runtime]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "AWS Lambda Runtime")
    technical_domains[Infrastructure_Automation]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Infrastructure Automation")
    technical_domains[Database_Technology]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Database Technology")
    technical_domains[API_Infrastructure]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "API Infrastructure")
    technical_domains[Development_Workflow]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Development Workflow")
    technical_domains[Local_Development]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Local Development")
    technical_domains[Application_Logic]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Application Logic")
    technical_domains[Integration_Patterns]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Integration Patterns")
    technical_domains[Security_Implementation]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Security Implementation")
    technical_domains[Observability]=$(extract_domain_keywords "TECHNICAL_DOMAINS.md" "Observability")
    
    # Domain detection
    detected_business_domains=()
    detected_technical_domains=()
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${DOMAIN} Business domain detection:"
    fi
    
    # Detect business domains
    for domain in "${!business_domains[@]}"; do
        keywords="${business_domains[$domain]}"
        if [[ -n "$keywords" ]]; then
            match_count=0
            for keyword in $keywords; do
                if [[ "$keyword" == *" "* ]]; then
                    if echo "$ticket_content" | grep -q -i "$keyword"; then
                        match_count=$((match_count + 1))
                    fi
                else
                    if echo "$ticket_content" | grep -q -i -w "$keyword"; then
                        match_count=$((match_count + 1))
                    fi
                fi
            done
            
            if [[ $match_count -ge 3 ]]; then
                detected_business_domains+=("$domain")
                if [[ "$VERBOSE" == true ]]; then
                    echo -e "${SUCCESS} ‚Ä¢ $domain ($match_count keywords matched)"
                fi
            elif [[ "$VERBOSE" == true && $match_count -ge 2 ]]; then
                echo -e "${INFO} ‚Ä¢ $domain ($match_count keywords matched - moderate signal)"
            elif [[ "$VERBOSE" == true && $match_count -eq 1 ]]; then
                echo -e "${INFO} ‚Ä¢ $domain (1 keyword matched - weak signal)"
            fi
        fi
    done
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${DOMAIN} Technical domain detection:"
    fi
    
    # Detect technical domains  
    for domain in "${!technical_domains[@]}"; do
        keywords="${technical_domains[$domain]}"
        if [[ -n "$keywords" ]]; then
            match_count=0
            for keyword in $keywords; do
                if [[ "$keyword" == *" "* ]]; then
                    if echo "$ticket_content" | grep -q -i "$keyword"; then
                        match_count=$((match_count + 1))
                    fi
                else
                    if echo "$ticket_content" | grep -q -i -w "$keyword"; then
                        match_count=$((match_count + 1))
                    fi
                fi
            done
            
            if [[ $match_count -ge 2 ]]; then
                detected_technical_domains+=("$domain")
                if [[ "$VERBOSE" == true ]]; then
                    echo -e "${SUCCESS} ‚Ä¢ $domain ($match_count keywords matched)"
                fi
            elif [[ "$VERBOSE" == true && $match_count -eq 1 ]]; then
                echo -e "${INFO} ‚Ä¢ $domain (1 keyword matched - weak signal)"
            fi
        fi
    done
    
    # Integration Pattern Analysis
    business_domain_count=${#detected_business_domains[@]}
    technical_domain_count=${#detected_technical_domains[@]}
    
    # Define known integration patterns (architectural necessities)
    integration_pattern=""
    is_valid_integration=false
    
    if [[ $business_domain_count -gt 1 ]]; then
        # Check for valid cross-domain integration patterns
        domains_sorted=$(printf '%s\n' "${detected_business_domains[@]}" | sort | tr '\n' ' ' | sed 's/ $//')
        
        case "$domains_sorted" in
            "Balance Provider")
                integration_pattern="Provider + Balance Integration"
                is_valid_integration=true
                ;;
            "EventSourcing Provider")
                integration_pattern="EventSourcing + Provider Integration"
                is_valid_integration=true
                ;;
            "Balance Quote")
                integration_pattern="Quote + Balance Integration"
                is_valid_integration=true
                ;;
            "Balance EventSourcing Provider")
                integration_pattern="Provider + Balance + EventSourcing Integration"
                is_valid_integration=true
                ;;
            "EventSourcing Payout")
                integration_pattern="Payout + EventSourcing Integration"
                is_valid_integration=true
                ;;
            "Balance Payout")
                integration_pattern="Payout + Balance Integration"
                is_valid_integration=true
                ;;
            "Provider Routing")
                integration_pattern="Provider + Routing Integration"
                is_valid_integration=true
                ;;
        esac
        
        if [[ "$is_valid_integration" == true ]]; then
            good_pattern_matches+=("Cross-Domain Integration: $integration_pattern")
            confidence_score=$((confidence_score + 15))  # Moderate bonus for valid integration
        else
            bad_pattern_indicators+=("Multiple Business Domains: ${detected_business_domains[*]}")
            confidence_score=$((confidence_score - 50))
        fi
    fi
    
    if [[ $technical_domain_count -gt 4 ]]; then
        bad_pattern_indicators+=("Too Many Technical Domains (${technical_domain_count}): ${detected_technical_domains[*]}")
        confidence_score=$((confidence_score - 30))
    fi
    
    # Domain-based concerns
    if [[ $business_domain_count -eq 2 ]]; then
        concerns+=("Two business domains: ${detected_business_domains[*]} - verify cohesive workflow")
    fi
    
    if [[ $technical_domain_count -eq 4 || $technical_domain_count -eq 5 ]]; then
        concerns+=("Multiple technical domains (${technical_domain_count}): ${detected_technical_domains[*]} - ensure single business focus")
    fi
    
    if [[ "$VERBOSE" == false ]]; then
        echo -e "${DOMAIN} Detected: ${business_domain_count} business, ${technical_domain_count} technical domains"
    fi
fi

#############################################################################
# LAYER 2: EXAMPLE-BASED PATTERN ANALYSIS (always available)
#############################################################################

if [[ "$EFFECTIVE_MODE" == "adaptive" || "$EFFECTIVE_MODE" == "enhanced" ]]; then
    echo -e "${CHECK} Step 3: Pattern analysis..."
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${EXAMPLE} Checking for good patterns..."
    fi
    
    # Good Pattern Detection
    
    # Pattern 1: Single Domain Workflow
    if echo "$ticket_description" | grep -iq -E "(authentication|login|token)" && 
       echo "$ticket_description" | grep -iq -E "(api|endpoint|client)" && 
       ! echo "$ticket_description" | grep -iq -E "(database.*and.*frontend|ui.*and.*backend.*and.*database)"; then
        good_pattern_matches+=("Single Domain Workflow")
        confidence_score=$((confidence_score + 30))
    fi
    
    # Pattern 2: Component Implementation
    if echo "$ticket_description" | grep -iq -E "(middleware|component|service|client)" &&
       echo "$ticket_description" | grep -iq -E "(implement|create|build)" &&
       ! echo "$ticket_description" | grep -iq -E "(research.*and|design.*and.*implement|multiple|several)"; then
        good_pattern_matches+=("Component Implementation")  
        confidence_score=$((confidence_score + 25))
    fi
    
    # Pattern 3: API Integration
    if echo "$ticket_description" | grep -iq -E "(api|endpoint|http|rest)" &&
       echo "$ticket_description" | grep -iq -E "(call|request|response|client)" &&
       echo "$ticket_description" | grep -iq -E "(handle|process|manage)"; then
        good_pattern_matches+=("API Integration")
        confidence_score=$((confidence_score + 20))
    fi
    
    # Pattern 4: TDD Implementation
    if echo "$ticket_description" | grep -iq -E "(test|tdd)" &&
       echo "$ticket_description" | grep -iq -E "(implement|build|create)" &&
       ! echo "$ticket_description" | grep -iq -E "(write tests.*and.*implement|testing.*separately)"; then
        good_pattern_matches+=("TDD Process")
        confidence_score=$((confidence_score + 15))
    fi
    
    # Pattern 5: Database Infrastructure
    if echo "$ticket_description" | grep -iq -E "(database|schema|migration|table)" &&
       echo "$ticket_description" | grep -iq -E "(add|create|update|implement)" &&
       echo "$ticket_description" | grep -iq -E "(column|constraint|index|foreign key|migration script)" &&
       ! echo "$ticket_description" | grep -iq -E "(research.*and.*implement|design.*and.*build)"; then
        good_pattern_matches+=("Database Infrastructure")
        confidence_score=$((confidence_score + 35))
    fi
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${EXAMPLE} Checking for bad patterns..."
    fi
    
    # Bad Pattern Detection
    
    # Anti-pattern 1: Phase Mixing (but exclude TDD workflow and focused implementation)
    if echo "$ticket_description" | grep -iq -E "(research|investigate|analyze|explore)" && 
       echo "$ticket_description" | grep -iq -E "(implement|build|create)" &&
       echo "$ticket_description" | grep -iq -E "(then|after|once|first.*then)" &&
       ! echo "$ticket_description" | grep -iq -E "(test.*driven|tdd)" &&
       ! echo "$ticket_description" | grep -iq -E "(fix.*routing|investigate.*route|debug|troubleshoot)" &&
       ! echo "$ticket_description" | grep -iq -E "(dependency.*injection|configure.*services|register.*services|di.*setup)"; then
        bad_pattern_indicators+=("Sequential Phase Mixing (Research then Implementation)")
        confidence_score=$((confidence_score - 30))
    fi
    
    # Anti-pattern 2: Architecture + Implementation
    if echo "$ticket_description" | grep -iq -E "(design.*architect|plan.*system)" &&
       echo "$ticket_description" | grep -iq -E "(implement.*build|create.*develop)" &&
       echo "$ticket_description" | grep -iq -E "(and|then|also)"; then  
        bad_pattern_indicators+=("Design + Implementation Phase Mixing")
        confidence_score=$((confidence_score - 25))
    fi
    
    # Anti-pattern 3: Multiple Methods/Features (NEW DETECTION)
    # Skip method counting if this appears to be a code example or bug fix
    is_code_example=false
    if echo "$ticket_description" | grep -iq -E "(\`\`\`|current code|required implementation|reference implementation|example:|fix.*code|bug.*fix)"; then
        is_code_example=true
    fi
    
    if [[ "$is_code_example" == false ]]; then
        method_count=$(echo "$ticket_description" | grep -io -E "(Async|async)" | wc -l)
        feature_count=0
        
        # Count explicit method names
        if echo "$ticket_description" | grep -iq "AuthenticateAsync"; then feature_count=$((feature_count + 1)); fi
        if echo "$ticket_description" | grep -iq "ValidateTokenAsync"; then feature_count=$((feature_count + 1)); fi
        if echo "$ticket_description" | grep -iq "RefreshTokenAsync"; then feature_count=$((feature_count + 1)); fi
        if echo "$ticket_description" | grep -iq "GetProfilesAsync"; then feature_count=$((feature_count + 1)); fi
        if echo "$ticket_description" | grep -iq "GetProfileAsync"; then feature_count=$((feature_count + 1)); fi
        
        # Count other method patterns - but exclude methods in code blocks
        description_without_code=$(echo "$ticket_description" | sed '/\`\`\`/,/\`\`\`/d')
        additional_methods=$(echo "$description_without_code" | grep -io -E "([A-Z][a-z]+Async|Create[A-Z][a-z]+|Update[A-Z][a-z]+|Delete[A-Z][a-z]+|Get[A-Z][a-z]+)" | sort -u | wc -l)
        total_methods=$((feature_count + additional_methods))
        
        if [[ $total_methods -ge 4 ]]; then
            bad_pattern_indicators+=("Too Many Methods/Features (${total_methods}) - Break into focused subtasks")
            confidence_score=$((confidence_score - 40))
        elif [[ $feature_count -ge 3 && $method_count -ge 5 ]]; then
            bad_pattern_indicators+=("Multiple API Methods (${feature_count} methods) - Consider breakdown")
            confidence_score=$((confidence_score - 25))
        fi
    fi
    
    # Anti-pattern 4: Epic-level Scope (but exclude template boilerplate and focused fixes)
    epic_indicators=0
    
    # Skip epic detection for focused bug fixes or routing fixes
    is_focused_fix=false
    if echo "$ticket_description" | grep -iq -E "(fix.*endpoint|fix.*routing|debug|troubleshoot|resolve.*error)"; then
        is_focused_fix=true
    fi
    
    if [[ "$is_focused_fix" == false ]]; then
        if echo "$ticket_description" | grep -iq -E "(system|platform|infrastructure)" && 
           ! echo "$ticket_description" | grep -iq -E "(existing.*systems|integration.*with.*existing)"; then
            epic_indicators=$((epic_indicators + 1))
        fi
        if echo "$ticket_description" | grep -iq -E "(multiple|several|various|different)" &&
           ! echo "$ticket_description" | grep -iq -E "(multiple.*requests|various.*formats)"; then
            epic_indicators=$((epic_indicators + 1))
        fi
        if echo "$ticket_description" | grep -iq -E "(end.*to.*end|complete.*solution|full.*stack)"; then
            epic_indicators=$((epic_indicators + 1))
        fi
        
        if [ "$epic_indicators" -gt 1 ]; then
            bad_pattern_indicators+=("Epic-level Scope")
            confidence_score=$((confidence_score - 35))
        fi
    fi
    
    # Common concerns across enhanced/adaptive
    
    # Multiple verbs (but exclude template boilerplate verbs)
    # Get raw verb matches, then filter out template context
    raw_verbs=$(echo "$ticket_description" | grep -io -E "(implement|build|create|develop|design|research|analyze)" | sort -u)
    verb_count=0
    
    # Count verbs that aren't in template boilerplate context
    while IFS= read -r verb; do
        if [[ -n "$verb" ]]; then
            # Check if verb appears in template context (skip if it does)
            if ! echo "$ticket_description" | grep -i -B2 -A2 "$verb" | grep -iq -E "(test.*driven|following.*approach|definition.*done|implementation.*approach)"; then
                verb_count=$((verb_count + 1))
            fi
        fi
    done <<< "$raw_verbs"
    
    if [ "$verb_count" -gt 3 ]; then
        concerns+=("Multiple action verbs (${verb_count}) - verify single workflow")
    fi
    
    # Long description (but account for template boilerplate)
    desc_length=$(echo "$ticket_description" | wc -w)
    # Count template boilerplate words to adjust threshold
    template_words=$(echo "$ticket_description" | grep -o -E "(following test-driven development|Definition of Done|Implementation Approach|Important Note for Implementation)" | wc -l)
    adjusted_threshold=$((200 + template_words * 50))
    if [ "$desc_length" -gt "$adjusted_threshold" ]; then
        concerns+=("Long description (${desc_length} words) - consider scope focus")
    fi
    
    # External references
    if echo "$ticket_description" | grep -q -E "[A-Z]+-[0-9]+-[0-9]+"; then
        concerns+=("External reference numbers - clean up for Linear")
    fi
    
    # Unit tests as separate phase (should be integrated with TDD)
    if echo "$ticket_description" | grep -iq -E "(unit.*tests.*written.*and.*passing|write.*unit.*tests|unit.*tests.*for.*all)" && 
       ! echo "$ticket_description" | grep -iq -E "(test.*harness|bruno.*test|api.*test.*suite)"; then
        bad_pattern_indicators+=("Unit tests as separate phase - Use TDD approach instead")
        confidence_score=$((confidence_score - 15))
    fi
    

    # Integration tests in DoD (should only be for Bruno test tasks)
    if echo "$ticket_description" | grep -iq -E "(integration.*test|integration.*following)" && 
       ! echo "$ticket_description" | grep -iq -E "(bruno|api.*test.*suite|test.*automation|endpoint.*testing)"; then
        bad_pattern_indicators+=("Integration tests in DoD for non-Bruno task - Remove integration test requirement")
        confidence_score=$((confidence_score - 20))
    fi
    
    # Method/Feature count concerns (for borderline cases)
    if [[ $feature_count -eq 3 || ($total_methods -eq 3 && $method_count -ge 3) ]]; then
        concerns+=("Multiple methods detected (${total_methods}) - verify single interface focus")
    fi
    
    # Conjunction words (cross-domain mixing indicator, but allow technical details)
    if echo "$ticket_content" | grep -q -E "(and|plus|\+|also|additionally)" &&
       ! echo "$ticket_content" | grep -iq -E "(authentication.*and.*authorization|http.*methods.*and.*authentication|fix.*and.*ensure|route.*and.*endpoint)"; then
        concerns+=("Conjunction words detected - verify single task focus")
    fi
fi

#############################################################################
# LAYER 3: BASIC PATTERN MATCHING (fallback)
#############################################################################

if [[ "$EFFECTIVE_MODE" == "basic" ]]; then
    echo -e "${CHECK} Step 3: Basic pattern analysis..."
    
    # Basic hardcoded domain detection (fallback)
    basic_domains=()
    if echo "$ticket_description" | grep -iq -E "(database|schema|sql|migration)"; then
        basic_domains+=("Database")
    fi
    if echo "$ticket_description" | grep -iq -E "(frontend|ui|component|react|vue|angular)"; then
        basic_domains+=("Frontend")  
    fi
    if echo "$ticket_description" | grep -iq -E "(devops|deployment|docker|kubernetes|infrastructure)"; then
        basic_domains+=("DevOps")
    fi
    
    if [ ${#basic_domains[@]} -gt 2 ]; then
        bad_pattern_indicators+=("Multiple Unrelated Domains: ${basic_domains[*]}")
        confidence_score=$((confidence_score - 40))
    fi
    
    # Basic phase mixing detection
    if echo "$ticket_description" | grep -iq -E "(research|investigate)" && 
       echo "$ticket_description" | grep -iq -E "(implement|build)"; then
        bad_pattern_indicators+=("Phase Mixing Detected")
        confidence_score=$((confidence_score - 25))
    fi
    
    # Basic complexity indicators
    word_count=$(echo "$ticket_description" | wc -w)
    if [ "$word_count" -gt 150 ]; then
        concerns+=("Long description (${word_count} words)")
    fi
fi

#############################################################################
# FINAL DECISION LOGIC
#############################################################################

echo -e "${CHECK} Step 4: Validation summary..."
echo ""

# Show domain detection results (adaptive mode only)
if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
    echo -e "${DOMAIN} ${BLUE}Domain Analysis:${NC}"
    if [[ ${#detected_business_domains[@]} -eq 0 ]]; then
        echo -e "${INFO} Business Domains: None detected"
    else
        echo -e "${INFO} Business Domains (${business_domain_count}): ${detected_business_domains[*]}"
    fi
    if [[ ${#detected_technical_domains[@]} -eq 0 ]]; then
        echo -e "${INFO} Technical Domains: None detected"  
    else
        echo -e "${INFO} Technical Domains (${technical_domain_count}): ${detected_technical_domains[*]}"
    fi
    echo ""
fi

# Show patterns found
if [ ${#good_pattern_matches[@]} -gt 0 ]; then
    echo -e "${SUCCESS} ${GREEN}Good patterns detected:${NC}"
    for pattern in "${good_pattern_matches[@]}"; do
        echo -e "${SUCCESS} ‚Ä¢ $pattern"
    done
    echo ""
fi

if [ ${#bad_pattern_indicators[@]} -gt 0 ]; then
    echo -e "${WARNING} ${YELLOW}Problematic patterns detected:${NC}"
    for indicator in "${bad_pattern_indicators[@]}"; do
        echo -e "${WARNING} ‚Ä¢ $indicator"
    done
    echo ""
fi

if [ ${#concerns[@]} -gt 0 ]; then
    echo -e "${INFO} ${PURPLE}Additional considerations:${NC}"
    for concern in "${concerns[@]}"; do
        echo -e "${INFO} ‚Ä¢ $concern"
    done
    echo ""
fi

# Final recommendation
echo -e "${CHECK} ${BLUE}Final Recommendation:${NC}"
echo ""

# Agent readiness check prompt
echo -e "${WARNING} ${YELLOW}ASSIGNMENT READINESS CHECK:${NC}"
echo -e "${INFO} Before assigning this ticket, consider:"
echo -e "${INFO} ‚Ä¢ Is the intended agent available RIGHT NOW for new work?"
echo -e "${INFO} ‚Ä¢ Have you checked their current active tickets and status?"
echo -e "${INFO} ‚Ä¢ Are you following proper queue management (not multi-assigning)?"
echo -e "${INFO} ‚Ä¢ Is this assignment urgent enough to interrupt current work?"
echo -e "${INFO}"
echo -e "${INFO} ${PURPLE}Remember: Only assign if agent is ready NOW - use queues for future work${NC}"
echo ""

# Domain-based decision logic (adaptive mode)
if [[ "$EFFECTIVE_MODE" == "adaptive" && $business_domain_count -gt 1 && "$is_valid_integration" != true ]]; then
    echo -e "${BREAKDOWN} ${RED}BREAKDOWN REQUIRED - MULTIPLE BUSINESS DOMAINS${NC}"
    echo -e "${INFO} Ticket spans multiple business capabilities: ${detected_business_domains[*]}"
    echo -e "${INFO} This violates the single-domain principle"
    echo ""
    echo -e "${BLUE}Recommended Action:${NC}"
    echo -e "${INFO} ‚Ä¢ Split into separate tickets by business domain"
    for domain in "${detected_business_domains[@]}"; do
        echo -e "${INFO}   - Create focused ticket for $domain domain"
    done

elif [[ "$EFFECTIVE_MODE" == "adaptive" && $technical_domain_count -gt 4 && $business_domain_count -eq 0 ]]; then
    echo -e "${BREAKDOWN} ${RED}BREAKDOWN RECOMMENDED - TOO MANY TECHNICAL DOMAINS${NC}"
    echo -e "${INFO} Ticket spans too many technical areas (${technical_domain_count}): ${detected_technical_domains[*]}"
    echo -e "${INFO} Consider breaking into focused technical subtasks"

# Standard decision logic (all modes)
elif [ "$confidence_score" -ge 50 ] && [ ${#bad_pattern_indicators[@]} -eq 0 ]; then
    echo -e "${SUCCESS} ${GREEN}PROCEED WITH IMPLEMENTATION${NC}"
    echo -e "${INFO} This ticket follows good patterns and is ready for development"
    echo -e "${INFO} Confidence Score: ${confidence_score}/100"
    if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
        echo -e "${INFO} Domain Complexity: ${business_domain_count} business, ${technical_domain_count} technical"
    fi

elif [ "$confidence_score" -ge 20 ] && [ ${#bad_pattern_indicators[@]} -le 1 ]; then
    echo -e "${WARNING} ${YELLOW}PROCEED WITH CAUTION${NC}"
    echo -e "${INFO} Ticket has good elements but some concerns"
    echo -e "${INFO} Consider reviewing scope or approach"  
    echo -e "${INFO} Confidence Score: ${confidence_score}/100"
    if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
        echo -e "${INFO} Domain Complexity: ${business_domain_count} business, ${technical_domain_count} technical"
    fi
    
    if [ ${#concerns[@]} -gt 0 ]; then
        echo -e "${INFO} Address these concerns before starting:"
        for concern in "${concerns[@]}"; do
            echo -e "${INFO}   - $concern"
        done
    fi

elif [ ${#bad_pattern_indicators[@]} -gt 0 ]; then
    echo -e "${BREAKDOWN} ${RED}BREAKDOWN RECOMMENDED${NC}"
    echo -e "${INFO} Ticket contains problematic patterns that suggest breakdown needed"
    echo -e "${INFO} Confidence Score: ${confidence_score}/100"
    echo ""
    echo -e "${BLUE}Suggested Actions:${NC}"
    
    for indicator in "${bad_pattern_indicators[@]}"; do
        case "$indicator" in
            *"Multiple Business Domains"*)
                echo -e "${INFO} ‚Ä¢ Split by business domain: ${detected_business_domains[*]}"
                ;;
            *"Multiple Unrelated Domains"*)
                echo -e "${INFO} ‚Ä¢ Split into separate tickets by domain"
                ;;
            *"Too Many Technical Domains"*)
                echo -e "${INFO} ‚Ä¢ Break into focused technical subtasks"
                ;;
            *"Phase Mixing"*|*"Sequential Phase Mixing"*)
                echo -e "${INFO} ‚Ä¢ Create separate research and implementation tickets"
                ;;
            *"Design + Implementation"*)
                echo -e "${INFO} ‚Ä¢ Separate design and implementation phases"
                ;;
            *"Epic-level"*)
                echo -e "${INFO} ‚Ä¢ Convert to epic with focused implementation subtasks"
                ;;
            *"Integration tests in DoD"*)
                echo -e "${INFO} ‚Ä¢ Remove integration test requirement - only unit tests for feature development"
                echo -e "${INFO} ‚Ä¢ Integration tests only required for Bruno API test writing tasks"
                ;;  
            *"Unit tests as separate phase"*)
                echo -e "${INFO} ‚Ä¢ Replace with TDD approach - tests written during implementation"
                echo -e "${INFO} ‚Ä¢ Remove separate testing phases - integrate testing into development"
                ;;
        esac
    done

else
    echo -e "${WARNING} ${YELLOW}UNCLEAR PATTERN${NC}"
    echo -e "${INFO} Unable to match against known good/bad patterns"
    echo -e "${INFO} Manual review recommended"
    echo -e "${INFO} Confidence Score: ${confidence_score}/100"
    if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
        echo -e "${INFO} Domain Complexity: ${business_domain_count} business, ${technical_domain_count} technical"
    fi
fi

echo ""
echo -e "${VALIDATE} ${BLUE}Validation complete for ${TICKET_ID}${NC}"
echo -e "${LAYER} ${PURPLE}Validation Mode: ${EFFECTIVE_MODE}${NC}"

# Show available resources
if [[ "$EFFECTIVE_MODE" == "adaptive" ]]; then
    echo -e "${INFO} ${PURPLE}Domain matrices: BUSINESS_DOMAINS.md, TECHNICAL_DOMAINS.md${NC}"
fi
if [[ -f "GOOD_IMPLEMENTATION_TICKET_EXAMPLE.md" ]]; then
    echo -e "${INFO} ${PURPLE}Compare with: GOOD_IMPLEMENTATION_TICKET_EXAMPLE.md${NC}"
fi
