#!/bin/bash
# start-ticket command for Spectrum Development Framework
# Phase 2: Clean Implementation After Context Reset
# Purpose: Read ticket info from discover-ticket, set up workspace, begin focused implementation

# Configuration
# Use project-local tmp directory
SPECTRUM_TMP_DIR=".tmp"
TICKET_INFO_FILE="$SPECTRUM_TMP_DIR/spectrum-ticket-info.json"

# Colors and emoji
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'
SUCCESS="‚úÖ"
ERROR="‚ùå"
INFO="üìã"
WORKING="üîÑ"
DOWNLOAD="üì•"
FOLDER="üìÅ"
BRANCH="üå≥"
SAVE="üíæ"
RESET="üîÑ"

echo -e "${INFO} ${BLUE}Spectrum Development Framework - Ticket Implementation${NC}"
echo -e "${INFO} ${YELLOW}Phase 2: Clean Implementation (Post Context Reset)${NC}"
echo ""

# Check for ticket info from discover-ticket phase
if [[ -f "$TICKET_INFO_FILE" ]]; then
    echo -e "${SUCCESS} Found ticket info from discovery phase"
    
    # Extract ticket information
    ticket_id=$(jq -r '.ticket_id' "$TICKET_INFO_FILE")
    ticket_title=$(jq -r '.ticket_title' "$TICKET_INFO_FILE")
    downloaded_file=$(jq -r '.ticket_file' "$TICKET_INFO_FILE")
    
    echo -e "${INFO} Using discovered ticket: ${BLUE}$ticket_id${NC} - $ticket_title"
    echo -e "${INFO} Ticket file: $downloaded_file"
    
    # Validate the discovered file still exists
    if [[ ! -f "$downloaded_file" ]]; then
        echo -e "${ERROR} Discovered ticket file not found: $downloaded_file"
        echo -e "${INFO} Please re-run discovery phase: .tools/commands/discover-ticket"
        exit 1
    fi
    
else
    echo -e "${ERROR} No ticket info found from discovery phase"
    echo -e "${INFO} Please run discover-ticket first to identify a ticket:"
    echo -e "${INFO} 1. Run: ${BLUE}.tools/commands/discover-ticket${NC}"
    echo -e "${INFO} 2. Then run: ${BLUE}.tools/commands/start-ticket${NC}"
    echo ""
    echo -e "${ERROR} Cannot proceed without ticket information"
    exit 1
fi

# Validate ticket ID format
if [[ ! $ticket_id =~ ^[A-Za-z]{2,5}-[0-9]+$ ]]; then
    echo -e "${YELLOW} Warning: Ticket ID format should be ABC-123 (e.g., SIG-16, CEN-408, PROJ-1234)"
    echo -e "${INFO} Proceeding with provided ID: $ticket_id"
fi

# Validate file has content
if [[ ! -s "$downloaded_file" ]]; then
    echo -e "${ERROR} Ticket file is empty: $downloaded_file"
    exit 1
fi

echo -e "${SUCCESS} Ready to proceed with ticket: ${BLUE}$ticket_id${NC} - $ticket_title"
echo -e "${SUCCESS} Using ticket file: $downloaded_file ($(wc -l < "$downloaded_file") lines)"

# Domain detection function for AI agents - no interactive prompts
detect_domain() {
    local ticket_file="$1"
    local ticket_content=$(cat "$ticket_file" | tr '[:upper:]' '[:lower:]')
    
    # Check ticket content for domain keywords
    if echo "$ticket_content" | grep -q -E "(lambda|aws lambda|projection|event sourcing)"; then
        if [[ -d "src/Centro.Core/Lambda" ]]; then
            echo "src/Centro.Core/Lambda"
            return 0
        fi
    elif echo "$ticket_content" | grep -q -E "(balance|account|currency)"; then
        if [[ -d "src/Centro.Core/Balance" ]]; then
            echo "src/Centro.Core/Balance"
            return 0
        fi
    elif echo "$ticket_content" | grep -q -E "(quote|pricing|rate)"; then
        if [[ -d "src/Centro.Core/Quote" ]]; then
            echo "src/Centro.Core/Quote"
            return 0
        fi
    elif echo "$ticket_content" | grep -q -E "(payout|payment|transfer)"; then
        if [[ -d "src/Centro.Core/Payout" ]]; then
            echo "src/Centro.Core/Payout"
            return 0
        fi
    elif echo "$ticket_content" | grep -q -E "(api|controller|endpoint)"; then
        if [[ -d "src/Centro.Api" ]]; then
            echo "src/Centro.Api"
            return 0
        fi
    elif echo "$ticket_content" | grep -q -E "(infrastructure|aws|deployment)"; then
        if [[ -d "src/Centro.Infrastructure" ]]; then
            echo "src/Centro.Infrastructure"
            return 0
        fi
    fi
    
    # Return error - let AI agent decide
    return 1
}

# Validate domain exists or create it
ensure_domain_exists() {
    local domain_path="$1"
    if [[ ! -d "$domain_path" ]]; then
        echo -e "${WORKING} Creating domain folder: $domain_path"
        mkdir -p "$domain_path"
        
        # Create tickets subfolder for future archival if in src/
        if [[ "$domain_path" == src/* ]]; then
            mkdir -p "$domain_path/tickets"
        fi
    fi
}

# Domain detection and workspace setup
echo -e "\n${FOLDER} Step 1: Setting up ticket workspace..."
echo -e "${INFO} ${YELLOW}Detecting appropriate domain for ticket...${NC}"

if domain_folder=$(detect_domain "$downloaded_file"); then
    echo -e "${SUCCESS} Auto-detected domain: $domain_folder"
    domain=$(basename "$domain_folder")
    base_path=$(dirname "$domain_folder")
else
    echo -e "${ERROR} Could not auto-detect domain for this ticket"
    echo -e "${INFO} Available domains found in codebase:"
    find src/ -type d -name "Centro.*" | grep -v bin | grep -v obj | sort | sed 's/^/  - /'
    echo -e "  - tickets/ (fallback)"
    echo ""
    echo -e "${ERROR} ${RED}AI AGENT ACTION REQUIRED:${NC}"
    echo -e "${INFO} Please examine the ticket content and choose the appropriate domain:"
    echo -e "${INFO} 1. Move the ticket file to the correct domain folder manually"
    echo -e "${INFO} 2. Update the workflow state to reflect the correct domain"
    echo -e "${INFO} 3. Re-run start-ticket, or continue with current setup"
    echo ""
    echo -e "${YELLOW} Proceeding with fallback domain 'tickets' for now...${NC}"
    
    domain="tickets"
    base_path="."
    domain_folder="$base_path/$domain"
fi

# Ensure domain exists
ensure_domain_exists "$domain_folder"

# Step 2: Copy ticket to domain folder
echo -e "\n${FOLDER} Step 2: Creating ticket documentation..."

# Create clean filename
clean_title=$(echo "$ticket_title" | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-zA-Z0-9-]//g')
ticket_doc_path="$domain_folder/$ticket_id-$clean_title.md"

# Copy complete ticket file to domain folder
cp "$downloaded_file" "$ticket_doc_path"
echo -e "${SUCCESS} Created complete ticket documentation: $ticket_doc_path"

# Step 3: Create feature branch from latest dev
echo -e "\n${BRANCH} Step 3: Creating feature branch from latest dev..."

# Always branch from dev to prevent sync issues
target_branch="dev"
current_branch=$(git branch --show-current)

# Check if dev branch exists locally
if ! git show-ref --verify --quiet "refs/heads/$target_branch"; then
    echo -e "${ERROR} Local '$target_branch' branch not found"
    echo -e "${INFO} Checking if remote dev branch exists..."
    if git show-ref --verify --quiet "refs/remotes/origin/$target_branch"; then
        echo -e "${WORKING} Creating local '$target_branch' branch from remote..."
        git checkout -b "$target_branch" "origin/$target_branch" || {
            echo -e "${ERROR} Failed to create local dev branch from remote"
            exit 1
        }
    else
        echo -e "${ERROR} No dev branch found locally or on remote"
        echo -e "${INFO} Please ensure dev branch exists before creating feature branches"
        exit 1
    fi
fi

# Switch to dev branch if not already on it
if [[ "$current_branch" != "$target_branch" ]]; then
    echo -e "${WORKING} Switching to $target_branch branch..."
    git checkout "$target_branch" || {
        echo -e "${ERROR} Failed to checkout $target_branch branch"
        exit 1
    }
fi

# Pull latest from dev branch to ensure we have the most recent changes
echo -e "${WORKING} Pulling latest changes from origin/$target_branch..."
git pull origin "$target_branch" || {
    echo -e "${ERROR} Failed to pull latest $target_branch"
    echo -e "${INFO} Please check your network connection and remote access"
    exit 1
}

# Create feature branch
branch_name="feature/$ticket_id-$clean_title"
echo -e "${WORKING} Creating feature branch: $branch_name"
git checkout -b "$branch_name" || {
    echo -e "${ERROR} Failed to create feature branch"
    exit 1
}

echo -e "${SUCCESS} Created and switched to feature branch: $branch_name (based on latest $target_branch)"

# Step 4: Save workflow state
echo -e "\n${SAVE} Step 4: Saving workflow state..."

mkdir -p .tmp
cat > .tmp/current-ticket.json << EOF
{
  "ticket": "$ticket_id",
  "title": "$ticket_title",
  "domain": "$domain",
  "base_path": "$base_path",
  "domain_folder": "$domain_folder",
  "ticket_doc_path": "$ticket_doc_path",
  "branch": "$branch_name",
  "phase": "started",
  "created": "$(date -Iseconds)",
  "source_file": "$downloaded_file"
}
EOF

echo -e "${SUCCESS} Workflow state saved to .tmp/current-ticket.json"

# Summary and next steps
echo -e "\n${SUCCESS} Ticket workflow initialized successfully!"
echo -e "${INFO} Summary:"
echo "  Ticket: $ticket_id - $ticket_title"
echo "  Domain: $domain ($base_path)"
echo "  Documentation: $ticket_doc_path"
echo "  Branch: $branch_name"
echo "  Complete ticket details: $(wc -l < "$ticket_doc_path") lines"
echo ""
echo -e "${INFO} Next steps:"
echo "  1. Review complete ticket requirements in $ticket_doc_path"
echo "  2. Begin implementation work based on ticket requirements"
echo "  3. Use TDD approach if applicable: write tests first, then implementation"
echo "  4. Commit work regularly and push feature branch when ready"

# Clean up temp file if it was in temp location
if [[ "$downloaded_file" =~ ^(.tmp|/tmp|./tmp|$HOME/tmp) ]]; then
    echo -e "${INFO} Cleaning up temporary file: $downloaded_file"
    rm -f "$downloaded_file"
fi
