#!/bin/bash
# dependency-tree - Enhanced dependency visualization tool
# Provides comprehensive dependency analysis and visualization

# Colors and emoji
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'
SUCCESS="âœ…"
ERROR="âŒ"
WARNING="âš ï¸"
INFO="ğŸ“‹"
WORKING="ğŸ”„"
BLOCKED="ğŸš«"
TREE="ğŸŒ³"
CRITICAL="ğŸ”¥"

# Dependency file
DEPS_FILE=".ticket_dependencies.json"

# Usage check
if [ $# -lt 1 ]; then
    echo -e "${ERROR} Usage: ./dependency-tree <command> [arguments...]"
    echo -e "${INFO} Commands:"
    echo -e "${INFO}   show <ticket>                    # Enhanced tree view for single ticket"
    echo -e "${INFO}   epic <epic_ticket_id>            # Show all dependencies in an epic"
    echo -e "${INFO}   full                             # Show complete dependency graph"
    echo -e "${INFO}   cycles                           # Detect circular dependencies"
    echo -e "${INFO}   critical                         # Find critical path bottlenecks"
    echo -e "${INFO}   stats                            # Dependency statistics"
    echo -e "${INFO}   blocked                          # All currently blocked tickets"
    echo ""
    echo -e "${INFO} Examples:"
    echo -e "${INFO}   ./dependency-tree show CEN-784"
    echo -e "${INFO}   ./dependency-tree epic CEN-778"
    echo -e "${INFO}   ./dependency-tree full"
    echo -e "${INFO}   ./dependency-tree critical"
    exit 1
fi

command="$1"
ticket="$2"

# Initialize dependencies file if it doesn't exist
if [ ! -f "$DEPS_FILE" ]; then
    echo '{}' > "$DEPS_FILE"
fi

# Helper functions
validate_ticket() {
    local ticket_id="$1"
    if [[ ! "$ticket_id" =~ ^[A-Z]+-[0-9]+$ ]]; then
        echo -e "${ERROR} Invalid ticket format: $ticket_id (expected: XXX-123)"
        exit 1
    fi
}

get_ticket_info() {
    local ticket_id="$1"
    python3 -c "
import json
import subprocess
try:
    result = subprocess.run(['python3', './.tools/saber.py', 'get', '$ticket_id'], 
                          capture_output=True, text=True, timeout=10)
    if result.returncode == 0:
        data = json.loads(result.stdout)
        status = data['state']['name']
        title = data['title'][:50] + ('...' if len(data['title']) > 50 else '')
        assignee = data.get('assignee', {})
        assignee_name = assignee.get('name', 'Unassigned') if assignee else 'Unassigned'
        print(f'{status}|{title}|{assignee_name}')
    else:
        print('Unknown|Unknown Title|Unknown')
except:
    print('Unknown|Unknown Title|Unknown')
"
}

show_enhanced_tree() {
    local ticket="$1"
    validate_ticket "$ticket"
    
    echo -e "${TREE} ${BLUE}Enhanced Dependency Tree for $ticket${NC}"
    echo ""
    
    python3 -c "
import json
import subprocess

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            title = data['title'][:40] + ('...' if len(data['title']) > 40 else '')
            assignee = data.get('assignee', {})
            assignee_name = assignee.get('name', 'Unassigned') if assignee else 'Unassigned'
            return status, title, assignee_name
    except:
        pass
    return 'Unknown', 'Unknown Title', 'Unknown'

def get_status_symbol(status):
    if status == 'Done':
        return 'âœ…'
    elif status == 'In Progress':
        return 'ğŸ”„'
    elif status == 'Todo':
        return 'ğŸ“‹'
    elif status == 'Canceled':
        return 'âŒ'
    else:
        return 'â“'

def show_tree(ticket, data, visited=set(), level=0, max_level=10, path=None):
    if level > max_level:
        print('  ' * level + 'âš ï¸  (max depth reached)')
        return
        
    if path is None:
        path = []
    
    if ticket in path:
        print('  ' * level + f'ğŸ”„ {ticket} (circular reference)')
        return
    
    new_path = path + [ticket]
    indent = '  ' * level
    
    # Get ticket information
    status, title, assignee = get_ticket_info(ticket)
    status_symbol = get_status_symbol(status)
    
    # Color coding based on status
    color = ''
    if status == 'Done':
        color = '\033[0;32m'  # Green
    elif status == 'In Progress':
        color = '\033[0;33m'  # Yellow
    elif status == 'Todo':
        color = '\033[0;34m'  # Blue
    elif status == 'Canceled':
        color = '\033[0;31m'  # Red
    
    print(f'{indent}{status_symbol} {color}{ticket}\033[0m - {title}')
    print(f'{indent}    Status: {status} | Assignee: {assignee}')
    
    if ticket not in data:
        return
    
    ticket_data = data[ticket]
    blocked_by = ticket_data.get('blocked_by', [])
    blocks = ticket_data.get('blocks', [])
    
    if blocked_by:
        print(f'{indent}  â”œâ”€â”€ ğŸš« Blocked by ({len(blocked_by)}):')
        for i, dep in enumerate(blocked_by):
            connector = 'â”œâ”€â”€' if i < len(blocked_by) - 1 else 'â””â”€â”€'
            print(f'{indent}  â”‚   {connector}')
            show_tree(dep, data, visited.copy(), level + 3, max_level, new_path)
    
    if blocks:
        print(f'{indent}  â””â”€â”€ ğŸ”’ Blocks ({len(blocks)}):')
        for i, dep in enumerate(blocks):
            connector = 'â”œâ”€â”€' if i < len(blocks) - 1 else 'â””â”€â”€'
            print(f'{indent}      {connector}')
            show_tree(dep, data, visited.copy(), level + 3, max_level, new_path)

try:
    with open('$DEPS_FILE', 'r') as f:
        data = json.load(f)
    
    show_tree('$ticket', data)
    
except Exception as e:
    print(f'Error: {e}')
"
}

show_epic_dependencies() {
    local epic_ticket="$1"
    validate_ticket "$epic_ticket"
    
    echo -e "${TREE} ${PURPLE}Epic Dependencies for $epic_ticket${NC}"
    echo ""
    
    # First get all tickets in the epic
    python3 -c "
import json
import subprocess

def get_epic_tickets(epic_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', epic_id], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            children = data.get('children', {}).get('nodes', [])
            return [child['identifier'] for child in children]
    except:
        pass
    return []

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            title = data['title'][:50] + ('...' if len(data['title']) > 50 else '')
            return status, title
    except:
        pass
    return 'Unknown', 'Unknown Title'

def get_status_symbol(status):
    if status == 'Done':
        return 'âœ…'
    elif status == 'In Progress':
        return 'ğŸ”„'
    elif status == 'Todo':
        return 'ğŸ“‹'
    elif status == 'Canceled':
        return 'âŒ'
    else:
        return 'â“'

try:
    with open('$DEPS_FILE', 'r') as f:
        deps_data = json.load(f)
    
    # Get epic tickets
    epic_tickets = get_epic_tickets('$epic_ticket')
    if not epic_tickets:
        epic_tickets = ['$epic_ticket']
    
    print(f'ğŸ“Š Epic contains {len(epic_tickets)} tickets')
    print()
    
    # Show dependencies within the epic
    epic_deps = {}
    external_deps = {}
    
    for ticket in epic_tickets:
        if ticket in deps_data:
            ticket_deps = deps_data[ticket]
            blocked_by = ticket_deps.get('blocked_by', [])
            blocks = ticket_deps.get('blocks', [])
            
            # Categorize dependencies
            internal_blocked_by = [dep for dep in blocked_by if dep in epic_tickets]
            external_blocked_by = [dep for dep in blocked_by if dep not in epic_tickets]
            internal_blocks = [dep for dep in blocks if dep in epic_tickets]
            external_blocks = [dep for dep in blocks if dep not in epic_tickets]
            
            if internal_blocked_by or internal_blocks:
                epic_deps[ticket] = {
                    'blocked_by': internal_blocked_by,
                    'blocks': internal_blocks
                }
            
            if external_blocked_by or external_blocks:
                external_deps[ticket] = {
                    'blocked_by': external_blocked_by,
                    'blocks': external_blocks
                }
    
    # Show internal epic dependencies
    if epic_deps:
        print('ğŸ”— Internal Epic Dependencies:')
        for ticket, deps in epic_deps.items():
            status, title = get_ticket_info(ticket)
            symbol = get_status_symbol(status)
            print(f'  {symbol} {ticket} - {title}')
            
            if deps['blocked_by']:
                print(f'    ğŸš« Blocked by: {', '.join(deps['blocked_by'])}')
            if deps['blocks']:
                print(f'    ğŸ”’ Blocks: {', '.join(deps['blocks'])}')
            print()
    
    # Show external dependencies
    if external_deps:
        print('ğŸŒ External Dependencies:')
        for ticket, deps in external_deps.items():
            status, title = get_ticket_info(ticket)
            symbol = get_status_symbol(status)
            print(f'  {symbol} {ticket} - {title}')
            
            if deps['blocked_by']:
                print(f'    ğŸš« External Blockers: {', '.join(deps['blocked_by'])}')
            if deps['blocks']:
                print(f'    ğŸ”’ External Blocks: {', '.join(deps['blocks'])}')
            print()
    
    if not epic_deps and not external_deps:
        print('âœ¨ No dependencies found within or outside the epic')
        
except Exception as e:
    print(f'Error: {e}')
"
}

show_full_graph() {
    echo -e "${TREE} ${CYAN}Complete Dependency Graph${NC}"
    echo ""
    
    python3 -c "
import json
import subprocess

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            return status
    except:
        pass
    return 'Unknown'

def get_status_symbol(status):
    if status == 'Done':
        return 'âœ…'
    elif status == 'In Progress':
        return 'ğŸ”„'
    elif status == 'Todo':
        return 'ğŸ“‹'
    elif status == 'Canceled':
        return 'âŒ'
    else:
        return 'â“'

try:
    with open('$DEPS_FILE', 'r') as f:
        data = json.load(f)
    
    if not data:
        print('ğŸ“‹ No dependencies recorded')
        exit()
    
    # Group tickets by their dependency status
    independent = []
    has_dependencies = []
    
    for ticket, deps in data.items():
        blocked_by = deps.get('blocked_by', [])
        blocks = deps.get('blocks', [])
        
        if not blocked_by and not blocks:
            independent.append(ticket)
        else:
            has_dependencies.append(ticket)
    
    print(f'ğŸ“Š Total tickets with dependencies: {len(data)}')
    print(f'ğŸ”— Tickets with active dependencies: {len(has_dependencies)}')
    print(f'âœ¨ Independent tickets: {len(independent)}')
    print()
    
    # Show tickets with dependencies
    if has_dependencies:
        print('ğŸ”— Tickets with Dependencies:')
        for ticket in sorted(has_dependencies):
            deps = data[ticket]
            blocked_by = deps.get('blocked_by', [])
            blocks = deps.get('blocks', [])
            
            status = get_ticket_info(ticket)
            symbol = get_status_symbol(status)
            
            print(f'  {symbol} {ticket} ({status})')
            if blocked_by:
                print(f'    ğŸš« Blocked by: {', '.join(blocked_by)}')
            if blocks:
                print(f'    ğŸ”’ Blocks: {', '.join(blocks)}')
            print()
    
    # Show independent tickets
    if independent:
        print('âœ¨ Independent Tickets:')
        for ticket in sorted(independent):
            status = get_ticket_info(ticket)
            symbol = get_status_symbol(status)
            print(f'  {symbol} {ticket} ({status})')
        
except Exception as e:
    print(f'Error: {e}')
"
}

detect_cycles() {
    echo -e "${WARNING} ${YELLOW}Circular Dependency Detection${NC}"
    echo ""
    
    python3 -c "
import json

def find_cycles(data):
    def dfs(node, path, visited):
        if node in path:
            cycle_start = path.index(node)
            cycle = path[cycle_start:] + [node]
            return [cycle]
        
        if node in visited:
            return []
        
        visited.add(node)
        cycles = []
        
        if node in data:
            for blocked in data[node].get('blocks', []):
                cycles.extend(dfs(blocked, path + [node], visited))
        
        return cycles
    
    try:
        with open('$DEPS_FILE', 'r') as f:
            data = json.load(f)
        
        if not data:
            print('ğŸ“‹ No dependencies to check')
            return
        
        all_cycles = []
        visited = set()
        
        for ticket in data:
            if ticket not in visited:
                cycles = dfs(ticket, [], visited.copy())
                all_cycles.extend(cycles)
        
        if all_cycles:
            print(f'âš ï¸  Found {len(all_cycles)} circular dependencies:')
            print()
            for i, cycle in enumerate(all_cycles, 1):
                print(f'ğŸ”„ Cycle {i}: {' â†’ '.join(cycle)}')
            print()
            print('â— These cycles must be resolved before affected tickets can proceed')
        else:
            print('âœ… No circular dependencies detected')
        
    except Exception as e:
        print(f'Error: {e}')
"
}

show_critical_path() {
    echo -e "${CRITICAL} ${RED}Critical Path Analysis${NC}"
    echo ""
    
    python3 -c "
import json
import subprocess
from collections import defaultdict, deque

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            title = data['title'][:40] + ('...' if len(data['title']) > 40 else '')
            return status, title
    except:
        pass
    return 'Unknown', 'Unknown Title'

def get_status_symbol(status):
    if status == 'Done':
        return 'âœ…'
    elif status == 'In Progress':
        return 'ğŸ”„'
    elif status == 'Todo':
        return 'ğŸ“‹'
    elif status == 'Canceled':
        return 'âŒ'
    else:
        return 'â“'

def find_longest_paths(data):
    # Find tickets with no dependencies (starting points)
    start_tickets = []
    for ticket, deps in data.items():
        if not deps.get('blocked_by', []):
            start_tickets.append(ticket)
    
    # Calculate longest path from each starting point
    longest_paths = []
    
    def dfs_longest_path(ticket, path, visited):
        if ticket in visited:
            return []
        
        visited.add(ticket)
        current_path = path + [ticket]
        
        if ticket not in data or not data[ticket].get('blocks', []):
            return [current_path]
        
        all_paths = []
        for blocked_ticket in data[ticket].get('blocks', []):
            paths = dfs_longest_path(blocked_ticket, current_path, visited.copy())
            all_paths.extend(paths)
        
        return all_paths if all_paths else [current_path]
    
    for start in start_tickets:
        paths = dfs_longest_path(start, [], set())
        longest_paths.extend(paths)
    
    return sorted(longest_paths, key=len, reverse=True)

try:
    with open('$DEPS_FILE', 'r') as f:
        data = json.load(f)
    
    if not data:
        print('ğŸ“‹ No dependencies to analyze')
        exit()
    
    longest_paths = find_longest_paths(data)
    
    if not longest_paths:
        print('âœ… No dependency chains found')
        exit()
    
    print(f'ğŸ” Found {len(longest_paths)} dependency chains')
    print(f'ğŸ”¥ Longest chain has {len(longest_paths[0])} tickets')
    print()
    
    # Show top 5 longest paths
    print('ğŸ”¥ Critical Paths (longest dependency chains):')
    for i, path in enumerate(longest_paths[:5], 1):
        print(f'\\nğŸ“ Path {i} (length: {len(path)}):')
        
        for j, ticket in enumerate(path):
            status, title = get_ticket_info(ticket)
            symbol = get_status_symbol(status)
            
            connector = 'â””â”€â”€' if j == len(path) - 1 else 'â”œâ”€â”€'
            print(f'  {connector} {symbol} {ticket} - {title} ({status})')
            
            if j < len(path) - 1:
                print('  â”‚')
    
    # Find bottlenecks (tickets that block the most others)
    print('\\nğŸš§ Bottleneck Analysis:')
    bottlenecks = []
    for ticket, deps in data.items():
        blocks_count = len(deps.get('blocks', []))
        if blocks_count > 0:
            status, title = get_ticket_info(ticket)
            bottlenecks.append((ticket, blocks_count, status, title))
    
    bottlenecks.sort(key=lambda x: x[1], reverse=True)
    
    for ticket, count, status, title in bottlenecks[:5]:
        symbol = get_status_symbol(status)
        criticality = 'ğŸ”¥' if count >= 3 else 'âš ï¸' if count >= 2 else 'ğŸ“‹'
        print(f'  {criticality} {symbol} {ticket} - blocks {count} tickets ({status})')
        
except Exception as e:
    print(f'Error: {e}')
"
}

show_stats() {
    echo -e "${INFO} ${BLUE}Dependency Statistics${NC}"
    echo ""
    
    python3 -c "
import json
import subprocess

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            return status
    except:
        pass
    return 'Unknown'

try:
    with open('$DEPS_FILE', 'r') as f:
        data = json.load(f)
    
    if not data:
        print('ğŸ“‹ No dependency data available')
        exit()
    
    # Basic statistics
    total_tickets = len(data)
    total_blocked_by = sum(len(deps.get('blocked_by', [])) for deps in data.values())
    total_blocks = sum(len(deps.get('blocks', [])) for deps in data.values())
    
    print(f'ğŸ“Š Total tickets with dependencies: {total_tickets}')
    print(f'ğŸ”— Total dependency relationships: {total_blocked_by}')
    print(f'ğŸš« Total blocking relationships: {total_blocks}')
    print()
    
    # Status breakdown
    status_counts = {}
    for ticket in data:
        status = get_ticket_info(ticket)
        status_counts[status] = status_counts.get(status, 0) + 1
    
    print('ğŸ“ˆ Status Distribution:')
    for status, count in sorted(status_counts.items()):
        symbol = 'âœ…' if status == 'Done' else 'ğŸ”„' if status == 'In Progress' else 'ğŸ“‹'
        print(f'  {symbol} {status}: {count} tickets')
    print()
    
    # Dependency complexity
    complexity_stats = {
        'no_deps': 0,
        'simple': 0,    # 1-2 dependencies
        'moderate': 0,  # 3-5 dependencies
        'complex': 0    # 6+ dependencies
    }
    
    for ticket, deps in data.items():
        total_deps = len(deps.get('blocked_by', [])) + len(deps.get('blocks', []))
        if total_deps == 0:
            complexity_stats['no_deps'] += 1
        elif total_deps <= 2:
            complexity_stats['simple'] += 1
        elif total_deps <= 5:
            complexity_stats['moderate'] += 1
        else:
            complexity_stats['complex'] += 1
    
    print('ğŸ¯ Complexity Distribution:')
    print(f'  âœ¨ No dependencies: {complexity_stats['no_deps']} tickets')
    print(f'  ğŸ“‹ Simple (1-2 deps): {complexity_stats['simple']} tickets')
    print(f'  âš ï¸  Moderate (3-5 deps): {complexity_stats['moderate']} tickets')
    print(f'  ğŸ”¥ Complex (6+ deps): {complexity_stats['complex']} tickets')
    
except Exception as e:
    print(f'Error: {e}')
"
}

show_blocked_tickets() {
    echo -e "${BLOCKED} ${RED}Currently Blocked Tickets${NC}"
    echo ""
    
    python3 -c "
import json
import subprocess

def get_ticket_info(ticket_id):
    try:
        result = subprocess.run(['python3', './.tools/saber.py', 'get', ticket_id], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            status = data['state']['name']
            title = data['title'][:50] + ('...' if len(data['title']) > 50 else '')
            assignee = data.get('assignee', {})
            assignee_name = assignee.get('name', 'Unassigned') if assignee else 'Unassigned'
            return status, title, assignee_name
    except:
        pass
    return 'Unknown', 'Unknown Title', 'Unknown'

def get_status_symbol(status):
    if status == 'Done':
        return 'âœ…'
    elif status == 'In Progress':
        return 'ğŸ”„'
    elif status == 'Todo':
        return 'ğŸ“‹'
    elif status == 'Canceled':
        return 'âŒ'
    else:
        return 'â“'

try:
    with open('$DEPS_FILE', 'r') as f:
        data = json.load(f)
    
    if not data:
        print('ğŸ“‹ No dependency data available')
        exit()
    
    blocked_tickets = []
    
    for ticket, deps in data.items():
        blocked_by = deps.get('blocked_by', [])
        if not blocked_by:
            continue
        
        # Check if any blockers are still active
        active_blockers = []
        for blocker in blocked_by:
            blocker_status, _, _ = get_ticket_info(blocker)
            if blocker_status not in ['Done', 'Canceled']:
                active_blockers.append((blocker, blocker_status))
        
        if active_blockers:
            ticket_status, title, assignee = get_ticket_info(ticket)
            blocked_tickets.append((ticket, ticket_status, title, assignee, active_blockers))
    
    if not blocked_tickets:
        print('âœ… No currently blocked tickets!')
        exit()
    
    print(f'ğŸš« Found {len(blocked_tickets)} blocked tickets:')
    print()
    
    for ticket, status, title, assignee, blockers in blocked_tickets:
        symbol = get_status_symbol(status)
        print(f'{symbol} {ticket} - {title}')
        print(f'    Status: {status} | Assignee: {assignee}')
        print(f'    ğŸš« Blocked by:')
        
        for blocker, blocker_status in blockers:
            blocker_symbol = get_status_symbol(blocker_status)
            print(f'      {blocker_symbol} {blocker} ({blocker_status})')
        print()
        
except Exception as e:
    print(f'Error: {e}')
"
}

# Main command handling
case "$command" in
    "show")
        if [ $# -ne 2 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree show <ticket>"
            exit 1
        fi
        show_enhanced_tree "$ticket"
        ;;
    "epic")
        if [ $# -ne 2 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree epic <epic_ticket_id>"
            exit 1
        fi
        show_epic_dependencies "$ticket"
        ;;
    "full")
        if [ $# -ne 1 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree full"
            exit 1
        fi
        show_full_graph
        ;;
    "cycles")
        if [ $# -ne 1 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree cycles"
            exit 1
        fi
        detect_cycles
        ;;
    "critical")
        if [ $# -ne 1 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree critical"
            exit 1
        fi
        show_critical_path
        ;;
    "stats")
        if [ $# -ne 1 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree stats"
            exit 1
        fi
        show_stats
        ;;
    "blocked")
        if [ $# -ne 1 ]; then
            echo -e "${ERROR} Usage: ./dependency-tree blocked"
            exit 1
        fi
        show_blocked_tickets
        ;;
    *)
        echo -e "${ERROR} Unknown command: $command"
        echo -e "${INFO} Use ./dependency-tree without arguments for help"
        exit 1
        ;;
esac